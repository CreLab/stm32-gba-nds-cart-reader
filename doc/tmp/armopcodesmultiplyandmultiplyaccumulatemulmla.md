# ARM Opcodes: Multiply and Multiply-Accumulate (MUL, MLA)


**Opcode Format**

```
+-----------------------------------------------------------------------+
|       Bit    Expl.                                                    |
|       31-28  Condition                                                |
|       27-25  Must be 000b for this instruction                        |
|       24-21  Opcode                                                   |
|                                                                       |
|   0000b: MUL{cond}{S}   Rd,Rm,Rs        ;Rd=Rm*Rs     ;\works as both 
|                                                                       |
| 0001b: MLA{cond}{S}   Rd,Rm,Rs,Rn     ;Rd=Rm*Rs+Rn  ;/signed+unsigned |
|                                                                       |
|    0010b: UMAAL{cond}    RdLo,RdHi,Rm Rs ;RdHiLo=Rm*Rs+RdHi+RdLo;\un- 
|                                                                       |
| 0100b: UMULL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs          ; signed |
|                                                                       |
|       0101b: UMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs+RdHiLo   ;/ |
|               0110b: SMULL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs     |
|                                                                       |
|            0111b: SMLAL{cond}{S} RdLo,RdHi,Rm,Rs ;RdHiLo=Rm*Rs+RdHiLo |
|                                                                       |
|            1000b: SMLAxy{cond}   Rd,Rm,Rs,Rn     ;Rd=HalfRm*HalfRs+Rn |
|                                                                       |
|       1001b: SMLAWy{cond}   Rd,Rm,Rs,Rn     ;Rd=(Rm*HalfRs)/10000h+Rn |
|                                                                       |
|          1001b: SMULWy{cond}   Rd,Rm,Rs        ;Rd=(Rm*HalfRs)/10000h |
|                                                                       |
|    1010b: SMLALxy{cond}  RdLo,RdHi,Rm,Rs ;RdHiLo=RdHiLo+HalfRm*HalfRs |
|               1011b: SMULxy{cond}   Rd,Rm,Rs        ;Rd=HalfRm*HalfRs |
|       20     S                                                        |
|  - Set Condition Codes (0=No, 1=Yes) (Must be 0 for Halfword & UMAAL) |
|       19-16  Rd (or RdHi) - Destination Register (R0-R14)             |
|       15-12                                                           |
| Rn (or RdLo) - Accumulate Register  (R0-R14) (Set to 0000b if unused) |
|       11-8   Rs - Operand Register               (R0-R14)             |
|       For Non-Halfword Multiplies                                     |
|         7-4  Must be 1001b for these instructions                     |
|       For Halfword Multiplies                                         |
|         7    Must be 1 for these instructions                         |
|                                                                       |
|        6    y - Rs Top/Bottom flag (0=B=Lower 16bit, 1=T=Upper 16bit) |
|         5                                                             |
|     x - Rm Top/Bottom flag (as above), or 0 for SMLAW, or 1 for SMULW |
|         4    Must be 0 for these instructions                         |
|       3-0    Rm - Operand Register               (R0-R14)             |
+-----------------------------------------------------------------------+
```


**Multiply and Multiply-Accumulate (MUL, MLA)**
Restrictions: Rd may not be same as Rm. Rd,Rn,Rs,Rm may not be R15.
Note: Only the lower 32bit of the internal 64bit result are stored in
Rd, thus no sign/zero extension is required and MUL and MLA can be used
for both signed and unsigned calculations!
Execution Time: 1S+mI for MUL, and 1S+(m+1)I for MLA. Whereas \'m\
depends on whether/how many most significant bits of Rs are all zero or
all one. That is m=1 for Bit 31-8, m=2 for Bit 31-16, m=3 for Bit 31-24,
and m=4 otherwise.
Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or
C=not affected (ARMv5 and up), V=not affected. MUL/MLA supported by
ARMv2 and up.

**Multiply Long and Multiply-Accumulate Long (MULL, MLAL)**
Optionally supported, INCLUDED in ARMv3M, EXCLUDED in ARMv4xM/ARMv5xM.
Restrictions: RdHi,RdLo,Rm must be different registers. R15 may not be
used.
Execution Time: 1S+(m+1)I for MULL, and 1S+(m+2)I for MLAL. Whereas
\'m\' depends on whether/how many most significant bits of Rs are \"al
zero\" (UMULL/UMLAL) or \"all zero or all one\" (SMULL,SMLAL). That i
m=1 for Bit31-8, m=2 for Bit31-16, m=3 for Bit31-24, and m=4 otherwise.
Flags (if S=1): Z=zeroflag, N=signflag, C=destroyed (ARMv4 and below) or
C=not affected (ARMv5 and up), V=destroyed??? (ARMv4 and below???) or
V=not affected (ARMv5 and up).

**Signed Halfword Multiply (SMLAxy,SMLAWy,SMLALxy,SMULxy,SMULWy)**
Supported by E variants of ARMv5 and up, ie. ARMv5TE(xP).
Q-flag gets set on 32bit SMLAxy/SMLAWy addition overflows, however, the
result is NOT truncated (as it\'d be done with QADD opcodes).
Q-flag is NOT affected on (rare) 64bit SMLALxy addition overflows.
SMULxy/SMULWy cannot overflow, and thus leave Q-flag unchanged as well.
NZCV-flags are not affected by Halfword multiplies.
Execution Time: 1S+Interlock (SMULxy,SMLAxy,SMULWx,SMLAWx)
Execution Time: 1S+1I+Interlock (SMLALxy)

**Unsigned Multiply Accumulate Accumulate Long (UMAAL)**
Multiply with two 32bit additions, supposed to be used for
cryptography.
Flags are not affected.
ARMv6 and above.



