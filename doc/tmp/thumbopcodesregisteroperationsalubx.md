# THUMB Opcodes: Register Operations (ALU, BX)


**THUMB.1: move shifted register**

```
+-----------------------------------------------------------------------+
|       15-13  Must be 000b for 'move shifted register' instructions    |
|       12-11  Opcode                                                   |
|                                                                       |
|           00b: LSL{S} Rd,Rs,#Offset   (logical/arithmetic shift left) |
|                01b: LSR{S} Rd,Rs,#Offset   (logical    shift right)   |
|                10b: ASR{S} Rd,Rs,#Offset   (arithmetic shift right)   |
|                11b: Reserved (used for add/subtract instructions)     |
|       10-6   Offset                     (0-31)                        |
|       5-3    Rs - Source register       (R0..R7)                      |
|       2-0    Rd - Destination register  (R0..R7)                      |
+-----------------------------------------------------------------------+
```

Example: LSL Rd,Rs,#nn ; Rd = Rs \<\< nn ; ARM equivalent: MOV
Rd,Rs,LSL #nn
Zero shift amount is having special meaning (same as for ARM shifts),
LSL#0 performs no shift (the carry flag remains unchanged), LSR/ASR#0
are interpreted as LSR/ASR#32. Attempts to specify LSR/ASR#0 in source
code are automatically redirected as LSL#0, and source LSR/ASR#32 is
redirected as opcode LSR/ASR#0.
Execution Time: 1S
Flags: Z=zeroflag, N=sign, C=carry (except LSL#0: C=unchanged),
V=unchanged.

**THUMB.2: add/subtract**

```
+-----------------------------------------------------------------------+
|       15-11  Must be 00011b for 'add/subtract' instructions           |
|       10-9   Opcode (0-3)                                             |
|                0: ADD{S} Rd,Rs,Rn   ;add register        Rd=Rs+Rn     |
|                1: SUB{S} Rd,Rs,Rn   ;subtract register   Rd=Rs-Rn     |
|                2: ADD{S} Rd,Rs,#nn  ;add immediate       Rd=Rs+nn     |
|                3: SUB{S} Rd,Rs,#nn  ;subtract immediate  Rd=Rs-nn     |
|              Pseudo/alias opcode with Imm=0:                          |
|                2: MOV{ADDS} Rd,Rs   ;move (affects cpsr) Rd=Rs+0      |
|       8-6    For Register Operand:                                    |
|                Rn - Register Operand (R0..R7)                         |
|              For Immediate Operand:                                   |
|                nn - Immediate Value  (0-7)                            |
|       5-3    Rs - Source register       (R0..R7)                      |
|       2-0    Rd - Destination register  (R0..R7)                      |
+-----------------------------------------------------------------------+
```

Return: Rd contains result, N,Z,C,V affected (including MOV).
Execution Time: 1S

**THUMB.3: move/compare/add/subtract immediate**

```
+-----------------------------------------------------------------------+
|       15-13  Must be 001b for this type of instructions               |
|       12-11  Opcode                                                   |
|                00b: MOV{S} Rd,#nn      ;move     Rd   = #nn           |
|                01b: CMP    Rd,#nn      ;compare  Void = Rd - #nn      |
|                10b: ADD{S} Rd,#nn      ;add      Rd   = Rd + #nn      |
|                11b: SUB{S} Rd,#nn      ;subtract Rd   = Rd - #nn      |
|       10-8   Rd - Destination Register  (R0..R7)                      |
|       7-0    nn - Unsigned Immediate    (0-255)                       |
+-----------------------------------------------------------------------+
```

ARM equivalents for MOV/CMP/ADD/SUB are MOVS/CMP/ADDS/SUBS same format.
Execution Time: 1S
Return: Rd contains result (except CMP), N,Z,C,V affected (for MOV only
N,Z).

**THUMB.4: ALU operations**

```
+-----------------------------------------------------------------------+
|       15-10  Must be 010000b for this type of instructions            |
|       9-6    Opcode (0-Fh)                                            |
|                0: AND{S} Rd,Rs     ;AND logical       Rd = Rd AND Rs  |
|                1: EOR{S} Rd,Rs     ;XOR logical       Rd = Rd XOR Rs  |
|                                                                       |
|       2: LSL{S} Rd,Rs     ;log. shift left   Rd = Rd << (Rs AND 0FFh) |
|                                                                       |
|       3: LSR{S} Rd,Rs     ;log. shift right  Rd = Rd >> (Rs AND 0FFh) |
|                                                                       |
|      4: ASR{S} Rd,Rs     ;arit shift right  Rd = Rd SAR (Rs AND 0FFh) |
|                                                                       |
|              5: ADC{S} Rd,Rs     ;add with carry    Rd = Rd + Rs + Cy |
|                                                                       |
|          6: SBC{S} Rd,Rs     ;sub with carry    Rd = Rd - Rs - NOT Cy |
|                                                                       |
|      7: ROR{S} Rd,Rs     ;rotate right      Rd = Rd ROR (Rs AND 0FFh) |
|                8: TST    Rd,Rs     ;test            Void = Rd AND Rs  |
|                9: NEG{S} Rd,Rs     ;negate            Rd = 0 - Rs     |
|                A: CMP    Rd,Rs     ;compare         Void = Rd - Rs    |
|                B: CMN    Rd,Rs     ;neg.compare     Void = Rd + Rs    |
|                C: ORR{S} Rd,Rs     ;OR logical        Rd = Rd OR Rs   |
|                D: MUL{S} Rd,Rs     ;multiply          Rd = Rd * Rs    |
|                                                                       |
|             E: BIC{S} Rd,Rs     ;bit clear         Rd = Rd AND NOT Rs |
|                F: MVN{S} Rd,Rs     ;not               Rd = NOT Rs     |
|       5-3    Rs - Source Register       (R0..R7)                      |
|       2-0    Rd - Destination Register  (R0..R7)                      |
+-----------------------------------------------------------------------+
```

ARM equivalent for NEG would be RSBS.
Return: Rd contains result (except TST,CMP,CMN),
Affected Flags:

```
+-----------------------------------------------------------------------+
|       N,Z,C,V for  ADC,SBC,NEG,CMP,CMN                                |
|       N,Z                                                             |
| ,C   for  LSL,LSR,ASR,ROR (carry flag unchanged if zero shift amount) |
|       N,Z,C   for  MUL on ARMv4 and below: carry flag destroyed       |
|       N,Z     for  MUL on ARMv5 and above: carry flag unchanged       |
|       N,Z     for  AND,EOR,TST,ORR,BIC,MVN                            |
+-----------------------------------------------------------------------+
```

Execution Time:

```
+-----------------------------------------------------------------------+
|       1S      for  AND,EOR,ADC,SBC,TST,NEG,CMP,CMN,ORR,BIC,MVN        |
|       1S+1I   for  LSL,LSR,ASR,ROR                                    |
|       1S+mI                                                           |
|    for  MUL on ARMv4 (m=1..4; depending on MSBs of incoming Rd value) |
|       1S+mI                                                           |
|  for  MUL on ARMv5 (m=3; fucking slow, no matter of MSBs of Rd value) |
+-----------------------------------------------------------------------+
```


**THUMB.5: Hi register operations/branch exchange**

```
+-----------------------------------------------------------------------+
|       15-10  Must be 010001b for this type of instructions            |
|       9-8    Opcode (0-3)                                             |
|                0: ADD Rd,Rs   ;add        Rd = Rd+Rs                  |
|                1: CMP Rd,Rs   ;compare  Void = Rd-Rs  ;CPSR affected  |
|                2: MOV Rd,Rs   ;move       Rd = Rs                     |
|                2: NOP         ;nop        R8 = R8                     |
|                                                                       |
|          3: BX  Rs      ;jump       PC = Rs     ;may switch THUMB/ARM |
|                                                                       |
|   3: BLX Rs      ;call       PC = Rs     ;may switch THUMB/ARM (ARM9) |
|       7                                                               |
|     MSBd - Destination Register most significant bit (or BL/BLX flag) |
|       6      MSBs - Source Register most significant bit              |
|                                                                       |
|      5-3    Rs - Source Register        (together with MSBs: R0..R15) |
|                                                                       |
|      2-0    Rd - Destination Register   (together with MSBd: R0..R15) |
+-----------------------------------------------------------------------+
```

Restrictions: For ADD/CMP/MOV, MSBs and/or MSBd must be set, ie. it is
not allowed that both are cleared.
When using R15 (PC) as operand, the value will be the address of the
instruction plus 4 (ie. \$+4). Except for BX R15: CPU switches to AR
state, and PC is auto-aligned as ((\$+4) AND NOT 2).
For BX, MSBs may be 0 or 1, MSBd must be zero, Rd is not used/zero.
For BLX, MSBs may be 0 or 1, MSBd must be set, Rd is not used/zero.
For BX/BLX, when Bit 0 of the value in Rs is zero:

```
+-----------------------------------------------------------------------+
|       Processor will be switched into ARM mode!                       |
|       If so, Bit 1 of Rs must be cleared (32bit word aligned).        |
|                                                                       |
|   Thus, BX PC (switch to ARM) may be issued from word-aligned address |
|       o                                                               |
| nly, the destination is PC+4 (ie. the following halfword is skipped). |
+-----------------------------------------------------------------------+
```

BLX may not use R15. BLX saves the return address as LR=PC+3 (with thumb
bit).
Using BLX R14 is possible (sets PC=Old_LR, and New_LR=retadr).
Assemblers/Disassemblers should use MOV R8,R8 as NOP (in THUMB mode).
Return: Only CMP affects CPSR condition flags!
Execution Time:

```
+-----------------------------------------------------------------------+
|      1S     for ADD/MOV/CMP                                           |
|      2S+1N  for ADD/MOV with Rd=R15, and for BX                       |
+-----------------------------------------------------------------------+
```




