# BIOS RSA Basics


### RSA Basics
The RSA formulas are quite simple: Applying an exponent and modulus to the source data. There are two formulas used for encryption/decryption. The first formula requires only the Public Key (and an exponent, which is usually some fixed constant; on the DSi it\'s always 10001h aka 65537 decimal). The second formula is almost same, but requires the Private Key instead of the constant exponent (and also requires the Public Key as modulus):

```
+-----------------------------------------------------------------------+
|       Public Key formula:      dest = src^10001h mod pubkey           |
|       Private Key formula:     dest = src^prvkey mod pubkey           |
+-----------------------------------------------------------------------+
```

That formulas can be used for encrypting secret messages, as so:

```
+-----------------------------------------------------------------------+
|       Recipient's Public Key   --> Encrypt a message                  |
|       Recipient's Private Key  --> Decrypt a message                  |
+-----------------------------------------------------------------------+
```

Or, using the formulas the other way around, to create digital signatures:

```
+-----------------------------------------------------------------------+
|       Sender's Private Key     --> Encrypt/create a signature         |
|       Sender's Public Key      --> Decrypt/verify a signature         |
+-----------------------------------------------------------------------+
```

The overall idea is that only the owner of the Private Key can decrypt messages, or create signatures. The Public Key can be shared freely, so that everybody can encrypt messages, or verify signatures.

### RSA Big Number Maths
The exponent/modulus can be implemented with simple unsigned multiply/divide operations. However, RSA requires dealing with big 1024bit integers (or even bigger numbers when using larger keys), this does usually require some software functions since regular CPUs cannot directly deal with such large numbers.

### RSA Byte Order
The DSi is storing all RSA keys and signatures in Big-Endian format, so one will need to reverse the byte order before doing the actual maths on Little-Endian CPUs.

### RSA Signatures (used on DSi)
Digital signatures can be used for signing documents or other binaries. The signature does usually consist of a secure checksum (SHA-1, MD5, SHA256, etc.) computed on the document/binary, and then encrypted via the RSA Private Key formula.
The checksum can be then decrypted via Public Key, if the decrypted checksum does match up, then one can be sure that the document/binary hasn\'t been modified, and that it was really created by the Private Key owner.

### RSA Encrypted Messages (not used on DSi)
Encrypted RSA messages are restricted to the size of the Public Key (eg. with a 1024bit key, the message should be smaller than 128 bytes). For bigger messages, one could either split the message into smaller snippets, or, one could combine RSA with some other encryption mechanism (eg. store an AES key in the RSA message, and decrypt the actual document via AES; that would add private/public key security to AES).

### RSA Padding
RSA can be weak if the message is a small number (especially very small values like \"0\" or \"1\" obviously wouldn\'t work well with the \"msg\^exp\" maths; other small values can be also weak, eg. with the common/small public exponent 10001h). To avoid that problem, the MSBs of the message should be padded with nonzero bytes, typically as so (as defined in RFC 2313):

```
+-------------------------------------------------------------------------------------+
|       00h   1      "00" Leading zero (00h)                                          |
|       01h   1      "BT" Block type (always 01h on DSi)                              |
|       02h   8+n    "PS" Padding (FFh-filled, min 8 bytes, usually 69h bytes on DSi) |
|       0Ah+n 1      "00" Padding end (00h)                                           |
|       0Bh+n 75h-n  "D"  Data (max 75h bytes, usually a 14h-byte SHA1 value on DSi)  |
+-------------------------------------------------------------------------------------+
```

That, for 80h-byte messages. For other sizes replace \"75h\" by \"F5h, 1F5h, etc.\"

### RSA Key Generation
Generating a RSA key pair is more difficult than the encryption/decryption part. First of, one needs two unsigned random prime numbers; for a 1024bit key, that would be usually two large 512bit prime numbers (whereas, finding real prime numbers is complicated, and it\'s more common to use values that have a \"high probability\" of being prime numbers).
The public key is then simply generated by multiplying the two prime numbers (P and Q) with each other:

```
+-----------------------------------------------------------------------+
|       pubkey = P * Q                                                  |
+-----------------------------------------------------------------------+
```

The private key is also based on the same prime numbers, but the maths there are more complicated (and not described here).
When knowing one prime number, one could theoretically compute the other as \"Q=pubkey/P\", however, prime numbers aren\'t as rare as one might think, and it\'s quite impossible to guess (or brute-force) one of the prime numbers.



