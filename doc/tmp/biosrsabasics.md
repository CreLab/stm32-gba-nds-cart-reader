# BIOS RSA Basics


**RSA Basics**
The RSA formulas are quite simple: Applying an exponent and modulus to
the source data. There are two formulas used for encryption/decryption.
The first formula requires only the Public Key (and an exponent, which
is usually some fixed constant; on the DSi it\'s always 10001h aka 6553
decimal). The second formula is almost same, but requires the Private
Key instead of the constant exponent (and also requires the Public Key
as modulus):

```
+-----------------------------------------------------------------------+
|       Public Key formula:      dest = src^10001h mod pubkey           |
|       Private Key formula:     dest = src^prvkey mod pubkey           |
+-----------------------------------------------------------------------+
```

That formulas can be used for encrypting secret messages, as so:

```
+-----------------------------------------------------------------------+
|       Recipient's Public Key   --> Encrypt a message                  |
|       Recipient's Private Key  --> Decrypt a message                  |
+-----------------------------------------------------------------------+
```

Or, using the formulas the other way around, to create digital
signatures:

```
+-----------------------------------------------------------------------+
|       Sender's Private Key     --> Encrypt/create a signature         |
|       Sender's Public Key      --> Decrypt/verify a signature         |
+-----------------------------------------------------------------------+
```

The overall idea is that only the owner of the Private Key can decrypt
messages, or create signatures. The Public Key can be shared freely, so
that everybody can encrypt messages, or verify signatures.

**RSA Big Number Maths**
The exponent/modulus can be implemented with simple unsigned
multiply/divide operations. However, RSA requires dealing with big
1024bit integers (or even bigger numbers when using larger keys), this
does usually require some software functions since regular CPUs cannot
directly deal with such large numbers.

**RSA Byte Order**
The DSi is storing all RSA keys and signatures in Big-Endian format, so
one will need to reverse the byte order before doing the actual maths on
Little-Endian CPUs.

**RSA Signatures (used on DSi)**
Digital signatures can be used for signing documents or other binaries.
The signature does usually consist of a secure checksum (SHA-1, MD5,
SHA256, etc.) computed on the document/binary, and then encrypted via
the RSA Private Key formula.
The checksum can be then decrypted via Public Key, if the decrypted
checksum does match up, then one can be sure that the document/binary
hasn\'t been modified, and that it was really created by the Private Ke
owner.

**RSA Encrypted Messages (not used on DSi)**
Encrypted RSA messages are restricted to the size of the Public Key (eg.
with a 1024bit key, the message should be smaller than 128 bytes). For
bigger messages, one could either split the message into smaller
snippets, or, one could combine RSA with some other encryption mechanism
(eg. store an AES key in the RSA message, and decrypt the actual
document via AES; that would add private/public key security to AES).

**RSA Padding**
RSA can be weak if the message is a small number (especially very small
values like \"0\" or \"1\" obviously wouldn\'t work well with th
\"msg\^exp\" maths; other small values can be also weak, eg. with th
common/small public exponent 10001h). To avoid that problem, the MSBs of
the message should be padded with nonzero bytes, typically as so (as
defined in RFC 2313):

```
+-----------------------------------------------------------------------+
|       00h   1      "00" Leading zero (00h)                            |
|       01h   1      "BT" Block type (always 01h on DSi)                |
|       02h   8+                                                        |
| n    "PS" Padding (FFh-filled, min 8 bytes, usually 69h bytes on DSi) |
|       0Ah+n 1      "00" Padding end (00h)                             |
|       0Bh+n 7                                                         |
| 5h-n  "D"  Data (max 75h bytes, usually a 14h-byte SHA1 value on DSi) |
+-----------------------------------------------------------------------+
```

That, for 80h-byte messages. For other sizes replace \"75h\" by \"F5h
1F5h, etc.\"

**RSA Key Generation**
Generating a RSA key pair is more difficult than the
encryption/decryption part. First of, one needs two unsigned random
prime numbers; for a 1024bit key, that would be usually two large 512bit
prime numbers (whereas, finding real prime numbers is complicated, and
it\'s more common to use values that have a \"high probability\" o
being prime numbers).
The public key is then simply generated by multiplying the two prime
numbers (P and Q) with each other:

```
+-----------------------------------------------------------------------+
|       pubkey = P * Q                                                  |
+-----------------------------------------------------------------------+
```

The private key is also based on the same prime numbers, but the maths
there are more complicated (and not described here).
When knowing one prime number, one could theoretically compute the other
as \"Q=pubkey/P\", however, prime numbers aren\'t as rare as one migh
think, and it\'s quite impossible to guess (or brute-force) one of th
prime numbers.



