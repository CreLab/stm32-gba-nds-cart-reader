# ARM CPU Flags & Condition Field (cond)


**ARM Condition Field {cond}**
The opcode {cond} suffixes can be used for conditionally executed code
based on the C,N,Z,V flags in CPSR register. For example: BEQ = Branch
if Equal, MOVMI = Move if Signed.
In ARM mode, {cond} can be used with all opcodes (except for a few newer
ARMv5 instructions: BKPT, PLD, CDP2, LDC2, MCR2, MRC2, STC2, and BLX_imm
are nonconditional; however BLX_reg can be conditional).
In THUMB mode, {cond} can be used only for branch opcodes.

```
+-----------------------------------------------------------------------+
|       Code Suffix Flags         Meaning                               |
|       0:   EQ     Z=1           equal (zero) (same)                   |
|       1:   NE     Z=0           not equal (nonzero) (not same)        |
|       2:   CS/HS  C=1           unsigned higher or same (carry set)   |
|       3:   CC/LO  C=0           unsigned lower (carry cleared)        |
|       4:   MI     N=1           signed negative (minus)               |
|       5:   PL     N=0           signed positive or zero (plus)        |
|       6:   VS     V=1           signed overflow (V set)               |
|       7:   VC     V=0           signed no overflow (V cleared)        |
|       8:   HI     C=1 and Z=0   unsigned higher                       |
|       9:   LS     C=0 or Z=1    unsigned lower or same                |
|       A:   GE     N=V           signed greater or equal               |
|       B:   LT     N<>V          signed less than                      |
|       C:   GT     Z=0 and N=V   signed greater than                   |
|       D:   LE     Z=1 or N<>V   signed less or equal                  |
|                                                                       |
|     E:   AL     -             always (the "AL" suffix can be omitted) |
|       F:                                                              |
|    NV     -             never (ARMv1,v2 only) (Reserved ARMv3 and up) |
+-----------------------------------------------------------------------+
```

Execution Time: If condition=false: 1S cycle. Otherwise: as specified
for the respective opcode.

**Current Program Status Register (CPSR)**

```
+-----------------------------------------------------------------------+
|       Bit   Expl.                                                     |
|                                                                       |
|   31    N - Sign Flag       (0=Not Signed, 1=Signed)               ;\ 
|       30    Z                                                         |
|  - Zero Flag       (0=Not Zero, 1=Zero)                   ; Condition |
|       29    C                                                         |
| - Carry Flag      (0=Borrow/No Carry, 1=Carry/No Borrow) ; Code Flags |
|                                                                       |
|   28    V - Overflow Flag   (0=No Overflow, 1=Overflow)            ;/ |
|                                                                       |
|    27    Q - Sticky Overflow (1=Sticky Overflow, ARMv5TE and up only) |
|                                                                       |
|  26-25 Reserved            (For future use) - Do not change manually! |
|       24                                                              |
|  J - Jazelle Mode    (1=Jazelle Bytecode instructions) (if supported) |
|                                                                       |
|  23-10 Reserved            (For future use) - Do not change manually! |
|                                                                       |
| 9     E - Endian          (... Big endian)                  (ARM11 ?) |
|       8                                                               |
|    A - Abort disable   (1=Disable Imprecise Data Aborts) (ARM11 only) |
|       7                                                               |
|      I - IRQ disable     (0=Enable, 1=Disable)                     ;\ 
|       6     F                                                         |
| - FIQ disable     (0=Enable, 1=Disable)                     ; Control |
|       5                                                               |
|  T - State Bit       (0=ARM, 1=THUMB) - Do not change manually!; Bits |
|       4                                                               |
| -0   M4-M0 - Mode Bits   (See below)                               ;/ |
+-----------------------------------------------------------------------+
```


**Bit 31-28: Condition Code Flags (N,Z,C,V)**
These bits reflect results of logical or arithmetic instructions. In ARM
mode, it is often optionally whether an instruction should modify flags
or not, for example, it is possible to execute a SUB instruction that
does NOT modify the condition flags.
In ARM state, all instructions can be executed conditionally depending
on the settings of the flags, such like MOVEQ (Move if Z=1). While In
THUMB state, only Branch instructions (jumps) can be made
conditionally.

**Bit 27: Sticky Overflow Flag (Q) - ARMv5TE and ARMv5TExP and up
only**
Used by QADD, QSUB, QDADD, QDSUB, SMLAxy, and SMLAWy only. These opcodes
set the Q-flag in case of overflows, but leave it unchanged otherwise.
The Q-flag can be tested/reset by MSR/MRS opcodes only.

**Bit 27-8: Reserved Bits (except Bit 27 on ARMv5TE and up, see
above)**
These bits are reserved for possible future implementations. For best
forwards compatibility, the user should never change the state of these
bits, and should not expect these bits to be set to a specific value.

**Bit 7-0: Control Bits (I,F,T,M4-M0)**
These bits may change when an exception occurs. In privileged modes
(non-user modes) they may be also changed manually.
The interrupt bits I and F are used to disable IRQ and FIQ interrupts
respectively (a setting of \"1\" means disabled).
The T Bit signalizes the current state of the CPU (0=ARM, 1=THUMB), this
bit should never be changed manually - instead, changing between ARM and
THUMB state must be done by BX instructions.
The Mode Bits M4-M0 contain the current operating mode.

```
+-----------------------------------------------------------------------+
|       Binary Hex Dec  Expl.                                           |
|                                                                       |
|   0xx00b 00h 0  - Old User       ;\26bit Backward Compatibility modes 
|       0xx0                                                            |
| 1b 01h 1  - Old FIQ        ; (supported only on ARMv3, except ARMv3G, |
|                                                                       |
| 0xx10b 02h 2  - Old IRQ        ; and on some non-T variants of ARMv4) |
|       0xx11b 03h 3  - Old Supervisor ;/                               |
|       10000b 10h 16 - User (non-privileged)                           |
|       10001b 11h 17 - FIQ                                             |
|       10010b 12h 18 - IRQ                                             |
|       10011b 13h 19 - Supervisor (SWI)                                |
|       10111b 17h 23 - Abort                                           |
|       11011b 1Bh 27 - Undefined                                       |
|       11111b 1Fh 31 - System (privileged 'User' mode) (ARMv4 and up)  |
+-----------------------------------------------------------------------+
```

Writing any other values into the Mode bits is not allowed.

**Saved Program Status Registers (SPSR\_\<mode\>)**
Additionally to above CPSR, five Saved Program Status Registers exist:
SPSR_fiq, SPSR_svc, SPSR_abt, SPSR_irq, SPSR_und
Whenever the CPU enters an exception, the current status register (CPSR)
is copied to the respective SPSR\_\<mode\> register. Note that there i
only one SPSR for each mode, so nested exceptions inside of the same
mode are allowed only if the exception handler saves the content of SPSR
in memory.
For example, for an IRQ exception: IRQ-mode is entered, and CPSR is
copied to SPSR_irq. If the interrupt handler wants to enable nested
IRQs, then it must first push SPSR_irq before doing so.



