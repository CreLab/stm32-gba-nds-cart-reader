# ARM CPU Exceptions


**Exception Vectors**
The following are the exception vectors in memory. That is, when an
exception arises, CPU is switched into ARM state, and the program
counter (PC) is loaded by the respective address.

```
+-----------------------------------------------------------------------+
|       Address                                                         |
|   Prio  Exception                  Mode on Entry      Interrupt Flags |
|                                                                       |
| BASE+00h 1     Reset                      Supervisor (_svc)  I=1, F=1 |
|       BASE+04h                                                        |
|  7     Undefined Instruction      Undefined  (_und)  I=1, F=unchanged |
|       BASE+08h                                                        |
|  6     Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged |
|       BASE+0Ch                                                        |
|  5     Prefetch Abort             Abort      (_abt)  I=1, F=unchanged |
|       BASE+10h                                                        |
|  2     Data Abort                 Abort      (_abt)  I=1, F=unchanged |
|       BASE+14h                                                        |
|  ??    Address Exceeds 26bit      Supervisor (_svc)  I=1, F=unchanged |
|       BASE+18h                                                        |
|  4     Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged |
|                                                                       |
| BASE+1Ch 3     Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1 |
+-----------------------------------------------------------------------+
```

BASE is normally 00000000h, but may be optionally FFFF0000h in some ARM
CPUs. Priority for simultaneously occuring exceptions ranges from
Prio=1=Highest to Prio=7=Lowest.
As there\'s only space for one ARM opcode at each of the abov
addresses, it\'d be usually recommended to deposit a Branch opcode int
each vector, which\'d then redirect to the actual exception handler
address.

**Actions performed by CPU when entering an exception**

```
+-----------------------------------------------------------------------+
|       - R14_<new mode>=PC+nn   ;save old PC, ie. return address       |
|       - SPSR_<new mode>=CPSR   ;save old flags                        |
|                                                                       |
|   - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode |
|                                                                       |
| - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions |
|       - CP                                                            |
| SR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only |
|       - PC=exception_vector    ;see table above                       |
+-----------------------------------------------------------------------+
```

Above \"PC+nn\" depends on the type of exception. Basically, in AR
state that nn-offset is caused by pipelining, and in THUMB state an
identical ARM-style \'offset\' is generated (even though the \'bas
address\' may be only halfword-aligned).

**Required user-handler actions when returning from an exception**
Restore any general registers (R0-R14) which might have been modified by
the exception handler. Use return-instruction as listed in the
respective descriptions below, this will both restore PC and CPSR - that
automatically involves that the old CPU state (THUMB or ARM) as well as
old state of FIQ and IRQ disable flags are restored.
As mentioned above (see action on entering\...), the return address i
always saved in ARM-style format, so that exception handler may use the
same return-instruction, regardless of whether the exception has been
generated from inside of ARM or THUMB state.

**FIQ (Fast Interrupt Request)**
This interrupt is generated by a LOW level on the nFIQ input. It is
supposed to process timing critical interrupts at a high priority, as
fast as possible.
Additionally to the common banked registers (R13_fiq,R14_fiq), five
extra banked registers (R8_fiq-R12_fiq) are available in FIQ mode. The
exception handler may freely access these registers without modifying
the main programs R8-R12 registers (and without having to save that
registers on stack).
In privileged (non-user) modes, FIQs may be also manually disabled by
setting the F Bit in CPSR.

**IRQ (Normal Interrupt Request)**
This interrupt is generated by a LOW level on the nIRQ input. Unlike
FIQ, the IRQ mode is not having its own banked R8-R12 registers.
IRQ is having lower priority than FIQ, and IRQs are automatically
disabled when a FIQ exception becomes executed. In privileged (non-user)
modes, IRQs may be also manually disabled by setting the I Bit in CPSR.
To return from IRQ Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq           |
+-----------------------------------------------------------------------+
```


**Software Interrupt**
Generated by a software interrupt instruction (SWI). Recommended to
request a supervisor (operating system) function. The SWI instruction
may also contain a parameter in the \'comment field\' of the opcode:
In case that your main program issues SWIs from both inside of THUMB and
ARM states, then your exception handler must separate between 24bit
comment fields in ARM opcodes, and 8bit comment fields in THUMB opcodes
(if necessary determine old state by examining T Bit in SPSR_svc);
However, in Little Endian mode, you could use only the most significant
8bits of the 24bit ARM comment field (as done in the GBA, for example) -
- the exception handler could then process the BYTE at \[R14-2\]
regardless of whether it\'s been called from ARM or THUMB state.
To return from Supervisor Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc               |
+-----------------------------------------------------------------------+
```

Note: Like all other exceptions, SWIs are always executed in ARM state,
no matter whether it\'s been caused by an ARM or THUMB state SW
instruction.

**Undefined Instruction Exception (supported by ARMv3 and up)**
This exception is generated when the CPU comes across an instruction
which it cannot handle. Most likely signalizing that the program has
locked up, and that an errormessage should be displayed.
However, it might be also used to emulate custom functions, ie. as an
additional \'SWI\' instruction (which\'d use R14_und and SPSR_un
though, and it\'d thus allow to execute the Undefined Instructio
handler from inside of Supervisor mode without having to save R14_svc
and SPSR_svc).
To return from Undefined Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und               |
+-----------------------------------------------------------------------+
```

Note that not all unused opcodes are necessarily producing an exception,
for example, an ARM state Multiply instruction with Bit6=1 would be
blindly accepted as \'legal\' opcode.

**Abort (supported by ARMv3 and up)**
Aborts (page faults) are mostly supposed for virtual memory systems (ie.
not used in GBA, as far as I know), otherwise they might be used just to
display an error message. Two types of aborts exists:
- Prefetch Abort (occurs during an instruction prefetch)
- Prefetch Abort (also occurs on BKPT opcodes, ARMv5 and up)
- Data Abort (occurs during a data access)
A virtual memory systems abort handler would then most likely determine
the fault address: For prefetch abort that\'s just \"R14_abt-4\". Fo
Data abort, the THUMB or ARM instruction at \"R14_abt-8\" needs to b
\'disassembled\' in order to determine the addressed data in memory.
The handler would then fix the error by loading the respective memory
page into physical memory, and then retry to execute the SAME
instruction again, by returning as follows:

```
+-----------------------------------------------------------------------+
|                                                                       |
|     prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt |
|                                                                       |
|     data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt |
+-----------------------------------------------------------------------+
```

Separate exception vectors for prefetch/data abort exists, each should
use the respective return instruction as shown above.

**Address Exceeds 26bit**
This exception can occur only on old ARM CPUs with 26bit address scheme
(or in 26bit backwards compatibility mode).

**Reset**
Forces PC=VVVV0000h, and forces control bits of CPSR to T=0 (ARM state),
F=1 and I=1 (disable FIQ and IRQ), and M4-0=10011b (Supervisor mode).



