# ARM CPU Exceptions


### Exception Vectors
The following are the exception vectors in memory. That is, when an exception arises, CPU is switched into ARM state, and the program counter (PC) is loaded by the respective address.

```
+-------------------------------------------------------------------------------------+
|       Address  Prio  Exception                  Mode on Entry      Interrupt Flags  |
|       BASE+00h 1     Reset                      Supervisor (_svc)  I=1, F=1         |
|       BASE+04h 7     Undefined Instruction      Undefined  (_und)  I=1, F=unchanged |
|       BASE+08h 6     Software Interrupt (SWI)   Supervisor (_svc)  I=1, F=unchanged |
|       BASE+0Ch 5     Prefetch Abort             Abort      (_abt)  I=1, F=unchanged |
|       BASE+10h 2     Data Abort                 Abort      (_abt)  I=1, F=unchanged |
|       BASE+14h ??    Address Exceeds 26bit      Supervisor (_svc)  I=1, F=unchanged |
|       BASE+18h 4     Normal Interrupt (IRQ)     IRQ        (_irq)  I=1, F=unchanged |
|       BASE+1Ch 3     Fast Interrupt (FIQ)       FIQ        (_fiq)  I=1, F=1         |
+-------------------------------------------------------------------------------------+
```

BASE is normally 00000000h, but may be optionally FFFF0000h in some ARM CPUs. Priority for simultaneously occuring exceptions ranges from Prio=1=Highest to Prio=7=Lowest.
As there\'s only space for one ARM opcode at each of the above addresses, it\'d be usually recommended to deposit a Branch opcode into each vector, which\'d then redirect to the actual exception handlers address.

### Actions performed by CPU when entering an exception

```
+---------------------------------------------------------------------------------+
|       - R14_<new mode>=PC+nn   ;save old PC, ie. return address                 |
|       - SPSR_<new mode>=CPSR   ;save old flags                                  |
|       - CPSR new T,M bits      ;set to T=0 (ARM state), and M4-0=new mode       |
|       - CPSR new I bit         ;IRQs disabled (I=1), done by ALL exceptions     |
|       - CPSR new F bit         ;FIQs disabled (F=1), done by Reset and FIQ only |
|       - PC=exception_vector    ;see table above                                 |
+---------------------------------------------------------------------------------+
```

Above \"PC+nn\" depends on the type of exception. Basically, in ARM state that nn-offset is caused by pipelining, and in THUMB state an identical ARM-style \'offset\' is generated (even though the \'base address\' may be only halfword-aligned).

### Required user-handler actions when returning from an exception
Restore any general registers (R0-R14) which might have been modified by the exception handler. Use return-instruction as listed in the respective descriptions below, this will both restore PC and CPSR - that automatically involves that the old CPU state (THUMB or ARM) as well as old state of FIQ and IRQ disable flags are restored.
As mentioned above (see action on entering\...), the return address is always saved in ARM-style format, so that exception handler may use the same return-instruction, regardless of whether the exception has been generated from inside of ARM or THUMB state.

### FIQ (Fast Interrupt Request)
This interrupt is generated by a LOW level on the nFIQ input. It is supposed to process timing critical interrupts at a high priority, as fast as possible.
Additionally to the common banked registers (R13_fiq,R14_fiq), five extra banked registers (R8_fiq-R12_fiq) are available in FIQ mode. The exception handler may freely access these registers without modifying the main programs R8-R12 registers (and without having to save that registers on stack).
In privileged (non-user) modes, FIQs may be also manually disabled by setting the F Bit in CPSR.

### IRQ (Normal Interrupt Request)
This interrupt is generated by a LOW level on the nIRQ input. Unlike FIQ, the IRQ mode is not having its own banked R8-R12 registers.
IRQ is having lower priority than FIQ, and IRQs are automatically disabled when a FIQ exception becomes executed. In privileged (non-user) modes, IRQs may be also manually disabled by setting the I Bit in CPSR.
To return from IRQ Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       SUBS PC,R14,4   ;both PC=R14_irq-4, and CPSR=SPSR_irq           |
+-----------------------------------------------------------------------+
```


### Software Interrupt
Generated by a software interrupt instruction (SWI). Recommended to request a supervisor (operating system) function. The SWI instruction may also contain a parameter in the \'comment field\' of the opcode:
In case that your main program issues SWIs from both inside of THUMB and ARM states, then your exception handler must separate between 24bit comment fields in ARM opcodes, and 8bit comment fields in THUMB opcodes (if necessary determine old state by examining T Bit in SPSR_svc); However, in Little Endian mode, you could use only the most significant 8bits of the 24bit ARM comment field (as done in the GBA, for example) - the exception handler could then process the BYTE at \[R14-2\], regardless of whether it\'s been called from ARM or THUMB state.
To return from Supervisor Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       MOVS PC,R14   ;both PC=R14_svc, and CPSR=SPSR_svc               |
+-----------------------------------------------------------------------+
```

Note: Like all other exceptions, SWIs are always executed in ARM state, no matter whether it\'s been caused by an ARM or THUMB state SWI instruction.

### Undefined Instruction Exception (supported by ARMv3 and up)
This exception is generated when the CPU comes across an instruction which it cannot handle. Most likely signalizing that the program has locked up, and that an errormessage should be displayed.
However, it might be also used to emulate custom functions, ie. as an additional \'SWI\' instruction (which\'d use R14_und and SPSR_und though, and it\'d thus allow to execute the Undefined Instruction handler from inside of Supervisor mode without having to save R14_svc and SPSR_svc).
To return from Undefined Mode (continuing at following opcode):

```
+-----------------------------------------------------------------------+
|       MOVS PC,R14   ;both PC=R14_und, and CPSR=SPSR_und               |
+-----------------------------------------------------------------------+
```

Note that not all unused opcodes are necessarily producing an exception, for example, an ARM state Multiply instruction with Bit6=1 would be blindly accepted as \'legal\' opcode.

### Abort (supported by ARMv3 and up)
Aborts (page faults) are mostly supposed for virtual memory systems (ie. not used in GBA, as far as I know), otherwise they might be used just to display an error message. Two types of aborts exists:
- Prefetch Abort (occurs during an instruction prefetch)
- Prefetch Abort (also occurs on BKPT opcodes, ARMv5 and up)
- Data Abort (occurs during a data access)
A virtual memory systems abort handler would then most likely determine the fault address: For prefetch abort that\'s just \"R14_abt-4\". For Data abort, the THUMB or ARM instruction at \"R14_abt-8\" needs to be \'disassembled\' in order to determine the addressed data in memory.
The handler would then fix the error by loading the respective memory page into physical memory, and then retry to execute the SAME instruction again, by returning as follows:

```
+-------------------------------------------------------------------------+
|       prefetch abort: SUBS PC,R14,#4   ;PC=R14_abt-4, and CPSR=SPSR_abt |
|       data abort:     SUBS PC,R14,#8   ;PC=R14_abt-8, and CPSR=SPSR_abt |
+-------------------------------------------------------------------------+
```

Separate exception vectors for prefetch/data abort exists, each should use the respective return instruction as shown above.

### Address Exceeds 26bit
This exception can occur only on old ARM CPUs with 26bit address scheme (or in 26bit backwards compatibility mode).

### Reset
Forces PC=VVVV0000h, and forces control bits of CPSR to T=0 (ARM state), F=1 and I=1 (disable FIQ and IRQ), and M4-0=10011b (Supervisor mode).



